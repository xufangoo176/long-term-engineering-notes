# Lock vs Version：分布式锁和乐观锁不是一回事

## 场景

在实际业务系统中，经常会遇到并发修改的问题，例如：

- 多个用户同时下单，扣减同一份库存
- 多个请求同时修改同一条订单数据
- 后台人员同时编辑同一个商品或配置

在这些场景下，很多系统会引入：

- 分布式锁（Redis Lock）
- 乐观锁（version 字段）

但在实际项目中，这两种方案经常被混用、误用，甚至被当成“同一个东西”。

本文尝试从**工程实践角度**说明：  
**分布式锁和乐观锁解决的问题并不相同。**

---

## 结论

- **乐观锁（version）**
    - 解决的是：并发更新导致的数据覆盖问题
    - 本质是：检测“这条数据有没有被别人改过”
    - 适合：单行数据更新、允许失败重试的场景

- **分布式锁**
    - 解决的是：跨线程 / 跨进程的临界区互斥问题
    - 本质是：保证一段业务逻辑同一时间只被一个执行
    - 适合：会产生副作用、涉及多步操作的场景

👉 **它们不是替代关系，而是解决不同问题。**

---

## 乐观锁（Version）的核心思想

### 它解决了什么问题？

乐观锁主要解决的是：

> 多个请求同时修改同一条记录，后提交的更新覆盖先提交的更新。

常见实现方式是给表加一个 `version` 字段：

```sql
version int not null default 0

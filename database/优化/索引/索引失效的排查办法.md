# 索引失效的排查办法

## 背景
索引失效是一个比较常见的问题。并且，这种情况一般是发生在有慢 SQL 时，我们才会去想这个 sql 变慢是否是因为索引失效，才导致的。

## 解决办法
1. 既然是发生在慢 sql，那么我们就通过 explain 去查看该 sql 的具体情况。
命令：explain + sql statement
2. 通过 explain 的返回结果，找到 key & type & extra 这 3 列，判断是否走了索引。<br/>
   2.1 如果走了索引。那先看是走了覆盖索引，还是索引下推，还是扫描了整颗索引树，还是用到了索引跳跃扫描。
    理想的走索引的情况：
    key: 一定有值，不为 null
    type： 应该是 ref、eq_ref、range、const 等几个
    extra： 如果是 NULL，或者 using index，using index condition 也可以
<br/>
   2.2 如果没走索引。找一找如下常见情况
    - 没有正确创建索引： 当查询语句中的 where 条件的字段，没有创建索引，或者不符合最左前缀匹配。那就索引创建这一步已经不正确了。
    - 索引区分度不高： 如果索引的区分度不够高，那么可能会不走索引，因为这种情况下走索引的效率并不高。解决办法是考虑换一个索引字段。
    - 表太小： 当表中的数据很小，优化器认为扫全表的成本也不高的时候，也可嫩不走索引。解决方法也很简单，表太小，走不走索引影响都不大。
    - 查询语句中，索引字段用到了函数、类型不一致等，也会导致索引失效。解决办法是需要去排查具体的失效原因，然后针对性调整 sql 就行。
    

## 实战例子

```sql
CREATE TABLE `mytable` (
`id` int(11) NOT NULL AUTO_INCREMENT,
`name` varchar(50) NOT NULL,
`age` int(11) DEFAULT NULL,
`create_time` datetime DEFAULT NULL,
PRIMARY KEY (`id`),
UNIQUE KEY `name` (`id`, `name`),
KEY `age` (`age`),
KEY `create_time` (`create_time`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

insert into mytable(id, name, age, create_time) values (1, "XuFan", 20, now());
insert into mytable(id, name, age, create_time) values (2, "XuFan1", 21, now());
insert into mytable(id, name, age, create_time) values (3, "XuFan2", 22, now());
insert into mytable(id, name, age, create_time) values (4, "XuFan3", 20, now());
insert into mytable(id, name, age, create_time) values (5, "XuFan4", 14, now());
insert into mytable(id, name, age, create_time) values (6, "XuFan5", 43, now());
insert into mytable(id, name, age, create_time) values (7, "XuFan6", 32, now());
insert into mytable(id, name, age, create_time) values (8, "XuFan7", 12, now());
insert into mytable(id, name, age, create_time) values (9, "XuFan8", 1, now());
insert into mytable(id, name, age, create_time) values (10, "XuFan9", 43, now());
```

### 以 age 字段为例子

索引不会失效的写法：
1、`select * from mytable where age = 12;`
2、`select * from mytable where age = 12 + 1;`

索引会失效的写法：
1、`select * from mytable where age + 1 = 12;`


### 以 create_time 字段为例子

索引不会失效的写法：
1、`select * from mytable where create_time = '2023-04-01 00:00:00';`

索引会失效的写法：
1、`select * from mytable where YEAR(create_time) = 2023;`
tips：使用了数据库函数，所以索引失效。但不是使用了函数，就一定失效。可以参考当前目录下的另一篇文章：（TODO 暂未写）

### 使用 or 关键字

索引不会失效的写法：
1、`select * from mytable where name = 'XuFan' and age > 18;`

索引会失效的写法：
1、`select * from mytable where name = 'XuFan' or age > 18;`
tips: or 的左右两边，只要出现 < 或者 >，那就会失效
但如果，这里的 age = 18，不使用 < 或者 >，即便用了 or 关键字，也不会造成索引失效。

### like
1、like '%xxx'
2、like '%xxx%'
这两种都会导致索引失效。只要是左边有 %，必定造成索引失效。
这里我有写过专门的一篇文章，去通过多种方式避免 like 导致的索引失效。在 模糊查询 这个目录下。
















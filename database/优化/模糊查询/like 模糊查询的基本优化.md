# like 的模糊查询如何优化

## 场景
在 sql 中，如果使用 like 关键字进行模糊查询，根据最左匹配原则，如果搜索条件是 '%' 开头，那就会造成当前字段的索引失效。
失效情况如下：
- like '%abc'
- like '%abc%'

不会失效的情况：
- like 'abc%'
- like 'abc%abcd'

总而言之：如果 '%' 在最左边，那就必然引起索引失效，如果是在中间或者最右边，则无需担心。可以通过 EXPLAIN 去看是否走了索引。


## 解决办法
有办法解决的，而且是有多种，可以根据不同的情况选择不同的优化方式。

### 优化方式1️⃣：
新建一个字段，存储原数据的倒叙，然后给这个新字段添加索引，并使用 like 模糊查询，把 '%' 顺利的放到右边进行查询，此时成功的避免了左边 '%' 导致的索引失效。<br/>
e.g.
1. 系统中已有 column_A 存储 '123abc' 的数据，当使用 like '%abc' 的时候，索引失效了。<br/>
2. 现在新建 column_B 存储 'cba321'，使用 like 'cba%'，数据正常被查询出来，且索引不会失效。
tips：想要做到 step 2，有一个数据库函数可以做到：UPDATE 'TABLE' SET 'column_B' = REVERSE('column_A');

缺点：
- 麻烦
- 表数据量如果比较大，执行 UPDATE 的 sql 还是比较耗时的。
- 增大表空间

### 优化方式2️⃣：
前置条件：MySQL version >= 5.7.6(如果达不到这个条件，就老老实实用上面的土方法)
使用虚拟列。
e.g. 
1. 创建虚拟列
ALTER TABLE 'test' ADD COLUMN 'v_name' VARCHAR(50) GENERATED ALWAYS AS (REVERSE('name')) VIRTUAL;
2. 为虚拟以列 v_name 列添加索引
ALTER TABLE 'test' ADD INDEX 'idx_name_virt'('v_name');

此时，使用新建的 v_name 去进行 like 模糊查询，就发现顺利走索引成功了。
tips： 虚拟列可以指定为VIRTUAL或STORED，VIRTUAL不会将虚拟列存储到磁盘中，在使用时MySQL会现场计算虚拟列的值，STORED会存储到磁盘中，相当于我们手动创建的冗余列。所以：如果你的磁盘足够大，可以使用STORED方式，这样在查询时速度会更快一些。

### 优化方式3️⃣：
（很多大厂都在用）冗余多个字段，组合起来存储。
e.g.
背景：现在有个表，有 5000 W+ 数据量。需求是查询手机号字段的后 4 位。
此时，问题就来了：左边的 7 位要通过模糊查询，那么索引必定失效。
解决方案：
1. 新增 3 个冗余字段。分别存储手机号的前 3 位，中间 4 位，以及最后 4 位。（这么设计是因为业务，比如很多查询是通过手机号的最后 4 位）
2. 给冗余字段建立索引
3. 可以直接去查询 part3 字段了

缺点：
1、浪费存储
2、手机号修改的话，对应的冗余字段也得修改。